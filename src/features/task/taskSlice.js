import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

var idCount = 3;
var itemId = 5;
const initialState = {
  value: 0,
  parentTasks: [
    { id: 0,
      tag: 'Template',
      name:'Friday, Jan 30',
      date: 'Jan 12, 2022, 1:03:54 AM',
      tasks: [
        {index: 0, task:'Do Laundry', comp: true},
        {index: 1, task:'Sleep for 6 hours', comp: true},
        {index: 2, task:'Tutorial Videos!', comp: true},
      ] 
    },
    { id: 1,
      tag: 'New',
      name:'February 12, 2022',
      date: 'April 12, 2021, 12:43:50 PM',
      tasks: [
        {index: 0, task:'Go Shopping', comp: false},
        {index: 1, task:'Watch Movies', comp: false},
        {index: 2, task:'Make some snacks', comp: false},
      ] 
    },
    { id: 2,
      name:'Valentines Day',
      tag: 'Template',
      date: 'July 12, 2021, 00:43:01 AM',
      tasks: [
        {index: 0, task:'Get a val gift', comp: false},
        {index: 1, task:'Make a reservation', comp: true},
        {index: 2, task:'Go out with babe', comp: false},
      ] 
    },
    { id: 3,
      name:'My Birthday',
      tag: 'New',
      date: 'May 1, 2020, 06:03:22 PM',
      tasks: [
        {index: 0, task:'Go out with Friends', comp: true},
        {index: 1, task:'Watch Movies', comp: false},
        {index: 2, task:'Go to church', comp: true},
      ] 
    }
  ]
};


// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const itemsSlice = createSlice({
  name: 'items',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addNewDay: (state, action) => {
      idCount = idCount + 1;
      const newId = idCount;
      return{
        ...state,
        parentTasks: [...state.parentTasks, 
          {
            id: newId, 
            name: action.payload.name,
            date: action.payload.date,
            tasks: []
          }
        ]
      }
    },

    addNewTask: (state, action)=> {
      const id = action.payload.id;
      
      const presentItem = state.parentTasks.find(item => item.id === id);
      let presentTasks = presentItem.tasks;

      const dayIndex = state.parentTasks.indexOf(presentItem);

      itemId++;

      const nextTask = {index: itemId, task: action.payload.name, comp: false}
      
      return {
        ...state,
        parentTasks: state.parentTasks.map(item=> item.id === id? {...item, tasks: [...item.tasks, nextTask]}: item)
      }
    },

    removeDay: (state, action)=> {
        return{
        ...state,
        parentTasks: state.parentTasks.filter(item => item.id !== action.payload.id)
      }
    },

    compDay: (state, action) => {
      const id = action.payload.id;
      return{
        ...state,
        parentTasks: state.parentTasks.map(item => 
          item.id === id? {...item, tasks: item.tasks.map(task => 
            task.comp === false? {...task, comp: true}:task)}:item)
      }
    },

    removeTask: (state, action)=> {
      const id = action.payload.id;
      const index = action.payload.index;

      return {
        ...state,
        parentTasks: state.parentTasks.map(item=> item.id === id?{...item, tasks:item.tasks.filter(task => task.index !== index)}: item)
      }
    },

    compTask: (state, action)=> {
      const id = action.payload.id;
      const index = action.payload.index;

      return {
        ...state,
        parentTasks: state.parentTasks.map(item=> 
          item.id === id?{...item, tasks:item.tasks.map(task => 
            task.index === index? {...task, comp:true}: task)}: item)
      }
    },

    undoTask: (state, action)=> {
      const id = action.payload.id;
      const index = action.payload.index;

      return {
        ...state,
        parentTasks: state.parentTasks.map(item=> 
          item.id === id?{...item, tasks:item.tasks.map(task => 
            task.index === index? {...task, comp:false}: task)}: item)
      }
    }
    
  },


  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = 'loading';
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle';
  //       state.value += action.payload;
  //     });
  // },
});

export const { addNewDay, addNewTask, removeDay, removeTask, compTask, undoTask, compDay} = itemsSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = (state) => state.items.value;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.


export default itemsSlice.reducer;
